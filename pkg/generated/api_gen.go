// Package generated provides primitives to interact the openapi HTTP API.
//
// This is an autogenerated file, any edits which you make here will be lost!
package generated

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"io"
	"net/http"
	"strings"
)

// ActorURI defines component schema for ActorURI.
type ActorURI string

// CustodianURI defines component schema for CustodianURI.
type CustodianURI string

// SimplifiedConsent defines component schema for SimplifiedConsent.
type SimplifiedConsent struct {
	Actors    []ActorURI   `json:"actors"`
	Custodian CustodianURI `json:"custodian"`
	Resources []string     `json:"resources"`
	Subject   SubjectURI   `json:"subject"`
}

// SubjectURI defines component schema for SubjectURI.
type SubjectURI string

// ValidationError defines component schema for ValidationError.
type ValidationError struct {
	Message string `json:"message"`
	Type    string `json:"type"`
}

// ValidationResponse defines component schema for ValidationResponse.
type ValidationResponse struct {
	Consent          *SimplifiedConsent `json:"consent,omitempty"`
	Outcome          string             `json:"outcome"`
	ValidationErrors []ValidationError  `json:"validationErrors,omitempty"`
}

// Client which conforms to the OpenAPI3 specification for this service. The
// server should be fully qualified with shema and server, ie,
// https://deepmap.com.
type Client struct {
	Server string
	Client http.Client
}

// Validate request with JSON body
func (c *Client) Validate(ctx context.Context, body ValidateRequestBody) (*http.Response, error) {
	req, err := NewValidateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// NewValidateRequest generates requests for Validate with JSON body
func NewValidateRequest(server string, body ValidateRequestBody) (*http.Request, error) {
	var bodyReader io.Reader

	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	return NewValidateRequestWithBody(server, "application/json", bodyReader)
}

// NewValidateRequestWithBody generates requests for Validate with non-JSON body
func NewValidateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryURL := fmt.Sprintf("%s/consent/validate", server)

	req, err := http.NewRequest("POST", queryURL, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// ValidateRequestBody defines body for Validate for application/json ContentType.
type ValidateRequestBody string

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Send a fhir consent record for validation. If valid the result will also include all accessible resources. (POST /consent/validate)
	Validate(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Validate converts echo context to params.
func (w *ServerInterfaceWrapper) Validate(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Validate(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/consent/validate", wrapper.Validate)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/5xVX4/jNBD/KiMvD7dS1BQOCZG344RQJXQ67XG8oD64zrTx4djGM+luWfW7o3HSZNv0",
	"6EKfvOux/Zvfn8mzMqGNwaNnUtWzItNgq/PyneGQPj+sZF0jmWQj2+BVpT4/rKDGrfXW74AbBC2lBXTU",
	"aecOoCEmbdhKOSZVKHzSbXSoKtUwR6rK0ndMC+9KW6OXQqRS7zZ3y/73gyoUH6IcIE7W79SxUO874lBb",
	"7W9j0h5C2mlv/9ayPSETsOZ0D4TUI/8fCJfXEH6ybXR2a7F+Hzyh5znMqQRMXwMJTUi1KlRMIWKSl+Rc",
	"RpZXlrHNi28SblWl7spJs3IQrBzVOo7AdEr6IH+PHd+65IziY6ESUuiS6QGdN/JOLoewhW1jE0yFxQR3",
	"xs8lLuo2X9DwLVSf+rKMKYP6q7MJa1X9cSLpZYsvUU9PrEWe6Z7blq41axhOn/snarai7StNsyF/9+Pw",
	"u+qa37WzdfbpzymFNMeW/w3caIZgTJcS1vDYWIewH44OmHd2j/6Wr1ok0jucP/NbH+ROO8AMpPiagrOT",
	"h4hihXysAjp41k/w5gsFD5Zgk8Kf6O+LjIyTtp6nTR8YdN/IuZXuC4jBWXOAN7lnz/ChYzlQIxCydE1Q",
	"h/4G58IjcGNpaPte5PFdKybp8YhJxveFlXy5Ws+6vLBY3i1G2tZnij0gRaF7zskDUudYWNmP1SD3IjE8",
	"Wm6yYqFjE1qciWSm+fGvyZgNnGOhTndWzyMDGYJE0/er9RVp9+c2fP3kufTvLOgXhJ7wrY+yY/02XJku",
	"H1dAEY3dWtNTtw0JTDpEDkCY9tYggd5r6/TGYSbUepD4nbaBojbCrLMGB4m8Fl7ULx9/3b/NOC3n+H54",
	"ee70SkSjCrXHRD2m5eLbxTITHNHraFWl3i6WC8l01NxknspBuHJgM78aA2UlReDczKpWlRorenaQ+KdQ",
	"HwbxeRBfx+gGBkpJzPSJvjJgz4nm1GE/wrNDM7zvlsv/9MDrZB9DkBFcxqB3fKMJNogeok6E9QJO+cgD",
	"FprgajqloegHCYH2dZm/0QaJrOg8jvaFCPH9rB3GJy6j0zY3Ms1nH8bsbYTlOVDrTUhJsMjkzwXUta1O",
	"B/lqo69B9/PpfLxmX07RWcBqCHyOd+qbfLTOgXYUwHrjuhplXn2lrUKx3pHk5DQDJCfHfwIAAP//ATqo",
	"XagJAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

