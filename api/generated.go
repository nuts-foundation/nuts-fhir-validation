/*
 * Nuts fhir validation
 * Copyright (C) 2019 Nuts community
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

// Package generated provides primitives to interact the openapi HTTP API.
//
// This is an autogenerated file, any edits which you make here will be lost!
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"strings"
)

// Identifier defines component schema for Identifier.
type Identifier string

// SimplifiedConsent defines component schema for SimplifiedConsent.
type SimplifiedConsent struct {
	Actors    []Identifier `json:"actors"`
	Custodian Identifier   `json:"custodian"`
	Resources []string     `json:"resources"`
	Subject   Identifier   `json:"subject"`
}

// ValidationError defines component schema for ValidationError.
type ValidationError struct {
	Message string `json:"message"`
	Type    string `json:"type"`
}

// ValidationResponse defines component schema for ValidationResponse.
type ValidationResponse struct {
	Consent          *SimplifiedConsent `json:"consent,omitempty"`
	Outcome          string             `json:"outcome"`
	ValidationErrors []ValidationError  `json:"validationErrors,omitempty"`
}

// ValidateRequestBody defines body for Validate for application/json ContentType.
type ValidateRequestBody string

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Send a fhir consent record for validation. If valid the result will also include all accessible resources. (POST /consent/validate)
	Validate(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Validate converts echo context to params.
func (w *ServerInterfaceWrapper) Validate(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Validate(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST("/consent/validate", wrapper.Validate)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/5RVXYtbNxD9K4NaaLZcbKcphAj80ISyXQhOyEdfmmUZS2NfpbKkSnO9axb/9zK611/r",
	"TZv1g5E9kubMOXNG98rEVYqBAhel71UxLa2wLq8sBXYLR1l+WSomu8QuBqXVJQXKzoDb74GukIVFzJAp",
	"ZSryf1jC64+zBnA5N9FSA8RmBFf8UwH0t7gpYGIonDvDZAELYIDPH2awiN7HW7Iw3wCCjd3cE5joY4Bn",
	"Wl8ABgvcUpCvHYSNZFuj7wjiogaWbk31vi9BNYrucJU8Ka1+hi4HHTouel6C1q+Gz+RLOAoNmLWe9J+X",
	"J1EKNkUXWGupgALvoo54ofPC6OcvX77S+t10RhZTA+8+T/8g9NwazNTAm+nsbQMfP00vyVvKHoNt4O30",
	"MkcKPjbwZjaVPDcmZos3ltbkY1pR4BsfDXrVKN4kKaZwdmGpto366FbJixT2TQ/pXLXDFhhgQyZJoRqV",
	"ckyU2VHVHg3HXFeOaVUXP2ZaKK1+GB8aZjx0y/ioVbZ7aJgzbuS36QpH6zA87ZpMJXbZ9IBOC/lNrhad",
	"F62ThtttbA5wz/h5iKp0869k+CmYKqh/OpfJKv3XjqTjAo9RH1Jcbxv1J3pnUfD/nnN8xFL1b+AWGaIx",
	"Xc5k4bZ1nqSr69GwPOrr/xFwRaXgks7TfGoJ0HCHHqgCab5F1dnJTareqsc0lE1gvINnX0sM4ArMc/yb",
	"wkUzeBpd4EMwRAbsCznV7KKBFL0zG3hWaw4Ms47lgCUoxFJ1ARv7G2QsALeuDGVfiLFDtxI1ejyixj6/",
	"sFIvV9dnVT7QskabPW2nin2gkoTuc04+UOk8Cyvr/W6Qe6kw3Dpuq2KxYxNXdCaSORj1v1rw3NnbRu3u",
	"1Pd7BioE8UDoV9ePSLs+bcPvt/jD/j1z1ANCd/iutxJxYREfsfH7KyiJjFs401Mn74fJm8QRCuW1M1QA",
	"1+g8yhMghLoAMhl3YSgJjTDrnaFBooDCi7p8/3b9ouJ0XAf/7PjcLksioxq1plx6TJPR89GkEpwoYHJK",
	"qxejyWgi4iG3lafxINx4YLNmTbFUJUXgWsyVVVrtd/TsUOHX0W4G8XkQH1PyAwNjcczhIX5kkp0Szbmj",
	"flbWDq3wfplMnpTg+2Tfm6AieGiDvuNbLDAnCpAwF7Ij2PmjzkFoo7dl54amHyTy6NtxzIDGUClOdN7P",
	"0JEI8etZOUx3PE4eXS3k8LKHuPfeXFg+B+qCiTkLFouMdUPpVivMG3keKVjAfj6djtfalwfrjOBqMHy1",
	"d+6LvHXeA/oSwQXjO0syr75RVqMYl0V8spsB4pPtvwEAAP//vlJooo4JAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

